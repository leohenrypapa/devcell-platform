# backend/app/services/training/malware_seed_tasks.py

from __future__ import annotations

import json
from datetime import date, timedelta
from typing import Any, Dict, List

from pydantic import BaseModel, Field

from app.core.llm_client import llm_chat
from app.schemas.training import MalwareTrainingWeek


# --- 24-week high-level syllabus for automation ---
# For brevity, Iâ€™m giving the first few weeks fully.
# You can extend the pattern for weeks 5â€“24 (or paste your full syllabus).
MALWARE_TRAINING_SYLLABUS: List[MalwareTrainingWeek] = [
    MalwareTrainingWeek(
        week=1,
        title="Orientation & Environment Basics",
        focus="Training philosophy, safety, lab setup, baseline tools.",
        objectives=[
            "Understand analysis-first, safety-first philosophy.",
            "Set up isolated lab environment for malware analysis.",
            "Become familiar with core tools and documentation habits.",
        ],
        labs=[
            "Install and configure analysis VMs.",
            "Document lab topology and safety rules.",
            "Practice basic OS navigation and logging into tools.",
        ],
    ),
    MalwareTrainingWeek(
        week=2,
        title="OS Internals: Processes, Threads, Memory",
        focus="How processes, threads, and memory behave on modern OSes.",
        objectives=[
            "Describe how processes and threads are represented in the OS.",
            "Inspect process and memory state using built-in tools.",
            "Relate process behavior to how malware hides and persists.",
        ],
        labs=[
            "Enumerate processes and analyze key attributes.",
            "Observe thread creation and termination in a sample program.",
            "Capture basic memory statistics and interpret them.",
        ],
    ),
    MalwareTrainingWeek(
        week=3,
        title="Windows API Basics",
        focus="Core Windows APIs for process, file, registry, and networking.",
        objectives=[
            "Identify malware-relevant Windows API families.",
            "Write simple benign programs that call Windows APIs.",
            "Explain how defenders observe API usage in logs/ETW.",
        ],
        labs=[
            "Compile a benign program that creates a process via documented APIs.",
            "Use a monitoring tool to log selected API calls.",
            "Summarize observed API usage in a short writeup.",
        ],
    ),
    MalwareTrainingWeek(
        week=4,
        title="PE File Format Fundamentals",
        focus="Layout and behavior of PE files: headers, sections, imports.",
        objectives=[
            "Explain the high-level structure of a PE file.",
            "Parse PE headers to identify imports and sections.",
            "Recognize anomalies that often appear in malicious binaries.",
        ],
        labs=[
            "Inspect PE files with standard tools and record findings.",
            "Write a small script to extract import tables.",
            "Compare multiple benign PE files and note differences.",
        ],
    ),
    # TODO: Fill out weeks 5â€“24 following the same pattern as needed.
]


class SeedTaskDraft(BaseModel):
    title: str
    description: str
    due_in_days: int = Field(7, ge=1, le=30)


def _ensure_week_prefix(title: str, week: int) -> str:
    """
    Normalize titles so they always start with a [WNN] prefix.
    Example: week=3 -> "[W03] <title>"

    - If title already starts with "[W03]", leave it.
    - If it starts with some other [W..], strip that and replace with [WNN].
    - Otherwise, just prepend [WNN].
    """
    prefix = f"[W{week:02d}]"
    stripped = title.strip()
    if stripped.startswith(prefix):
        return stripped

    # If it starts with some other [W..], remove that part first
    if stripped.startswith("[W") and "]" in stripped[:6]:
        stripped = stripped[stripped.index("]") + 1 :].lstrip()

    return f"{prefix} {stripped}" if stripped else prefix

def _fallback_seed_tasks(week_spec: MalwareTrainingWeek, task_count: int) -> List[SeedTaskDraft]:
    fallback: List[SeedTaskDraft] = [
        SeedTaskDraft(
            title=_ensure_week_prefix(
                "Read + summarize core theory",
                week_spec.week,
            ),
            description=(
                f"Read the primary notes for Week {week_spec.week} "
                f"({week_spec.title}) and write a 1-page summary focused on "
                "defensive takeaways and detection opportunities."
            ),
            due_in_days=5,
        ),
        SeedTaskDraft(
            title=_ensure_week_prefix(
                "Execute provided lab and capture screenshots",
                week_spec.week,
            ),
            description=(
                "Run the official lab scenario for this week in the isolated lab. "
                "Capture at least 3â€“5 screenshots that show key observations and "
                "annotate them with short captions."
            ),
            due_in_days=7,
        ),
        SeedTaskDraft(
            title=_ensure_week_prefix(
                "Write detection-minded reflection",
                week_spec.week,
            ),
            description=(
                "Write a reflection (5â€“10 bullet points) on how a defender could "
                "detect or monitor the behaviors discussed this week, based on "
                "lab observations and available telemetry."
            ),
            due_in_days=7,
        ),
    ]
    return fallback[:task_count]


async def generate_seed_tasks_for_week(
    week: int,
    task_count: int,
) -> List[SeedTaskDraft]:
    """
    Ask Qwen to generate benign, lab-only training tasks for a given week.
    If anything goes wrong, fall back to a small deterministic set.

    All returned titles are normalized to start with a [WNN] prefix so the
    frontend can group tasks per week easily.
    """

    # Look up the week spec
    week_spec = next((w for w in MALWARE_TRAINING_SYLLABUS if w.week == week), None)
    if week_spec is None:
        raise ValueError(f"Unknown training week: {week}")

    system_msg = (
        "You are designing training tasks for a DEFENSIVE malware-analysis course "
        "in a military cyber unit. All work is:\n"
        "- Lab-only\n"
        "- Benign payloads only\n"
        "- Focused on understanding, analysis, documentation, and detection\n"
        "- NO real-world malicious payloads\n"
        "- NO instructions for bypassing production security controls\n\n"
        "You MUST respond with JSON ONLY, no commentary, no markdown, no code fences.\n"
        "The JSON schema is:\n"
        "{\n"
        '  \"tasks\": [\n'
        "    {\n"
        '      \"title\": \"short title\",\n'
        '      \"description\": \"1-3 sentences, defensive/lab-only\",\n'
        '      \"due_in_days\": 7\n'
        "    }\n"
        "  ]\n"
        "}\n"
        "Do not include code samples, shell commands, or anything operationally dangerous."
    )

    user_msg = (
        "Design weekly training tasks for this malware-analysis syllabus week.\n\n"
        f"Week {week_spec.week}: {week_spec.title}\n"
        f"Focus: {week_spec.focus}\n"
        f"Objectives:\n- " + "\n- ".join(week_spec.objectives) + "\n\n"
        f"Labs:\n- " + "\n- ".join(week_spec.labs) + "\n\n"
        f"Generate {task_count} tasks."
    )

    messages = [
        {"role": "system", "content": system_msg},
        {"role": "user", "content": user_msg},
    ]

    # ---------- Call LLM ----------
    try:
        raw = await llm_chat(messages)
    except Exception as e:
        print(f"[training] LLM call failed, falling back: {e}")
        return _fallback_seed_tasks(week_spec, task_count)

    drafts: List[SeedTaskDraft] = []

    # ---------- 1) Try to extract clean JSON (strip fences, etc.) ----------
    try:
        text = raw.strip()

        # If model wrapped in ```json ... ``` or ``` ... ```
        if text.startswith("```"):
            # Remove starting/ending fences
            # e.g., ```json\n{...}\n```  -> {...}
            text = text.strip("`")  # remove backticks
            # Drop leading language tag like 'json\n'
            brace_idx = text.find("{")
            if brace_idx != -1:
                text = text[brace_idx:]

        # If still not starting with '{', try to find first JSON-looking block
        if not text.lstrip().startswith("{"):
            import re

            m = re.search(r"\{.*\}", text, flags=re.DOTALL)
            if m:
                text = m.group(0)

        data: Dict[str, Any] = json.loads(text)
        items = data.get("tasks", [])

        for item in items:
            try:
                title_raw = str(item.get("title", "")).strip()[:200]
                description_raw = str(item.get("description", "")).strip()
                due_raw = int(item.get("due_in_days", 7))

                if not title_raw:
                    continue

                drafts.append(
                    SeedTaskDraft(
                        title=_ensure_week_prefix(title_raw, week_spec.week),
                        description=description_raw,
                        due_in_days=due_raw,
                    )
                )
            except Exception:
                continue

        if drafts:
            return drafts[:task_count]
    except Exception as e:
        print(f"[training] JSON parsing failed, will try bullet parsing: {e}")

    # ---------- 2) Fallback parse: bullet list style ----------
    try:
        for line in raw.splitlines():
            stripped = line.strip()
            if not stripped:
                continue

            # Only consider actual bullets; ignore `{`, `"tasks": [`, etc.
            if stripped.startswith("- "):
                stripped = stripped[2:].strip()
            elif stripped.startswith("* "):
                stripped = stripped[2:].strip()
            else:
                continue  # ðŸ‘ˆ important: skip non-bullet lines

            # Split on em dash or " - "
            if "â€”" in stripped:
                title_part, desc_part = stripped.split("â€”", 1)
            elif " - " in stripped:
                title_part, desc_part = stripped.split(" - ", 1)
            else:
                title_part, desc_part = stripped, ""

            title_raw = title_part.strip()[:200]
            description_raw = desc_part.strip()

            if not title_raw:
                continue

            drafts.append(
                SeedTaskDraft(
                    title=_ensure_week_prefix(title_raw, week_spec.week),
                    description=(
                        description_raw or "See syllabus and lab guide for details."
                    ),
                    due_in_days=7,
                )
            )

        if drafts:
            return drafts[:task_count]
    except Exception as e:
        print(f"[training] Bullet parsing failed, using static fallback: {e}")

    # ---------- 3) Final deterministic fallback ----------
    return _fallback_seed_tasks(week_spec, task_count)
